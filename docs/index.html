<html>
<head>
  <title>Game3 | Docs</title>
  <!-- markdown stuff -->
  <script type="text/javascript" src="../js/markdown.min.js"></script>
  <!-- prettify stuff -->
  <link rel="stylesheet" href="../css/highlight.min.css">
  <script src="../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- custom -->
  <link rel="stylesheet" type="text/css" href="../css/layout.css" />
</head>
<body>
  <div class="info">
    <div class="nav">
      <a href="../">Game3</a>
      <a href="../examples/">Examples</a>
      <a href="../docs/">Docs</a>
    </div>
    <h1>Documentation</h1>
    <p class="important">Under development.</p>
    <p>For now, be sure to check out the full example pages and the source code on <a href="https://github.com/abhandaru/Game3">GitHub</a>. The code itself is well formed, commented, and split into files.</p>
    <article>
## Game3.Class

All classes in `Game3` derive from the base `Class`. It supports a familiar inheritance model, and should prove useful in your object oriented designs.


### Static Methods

### `.extend([parameters])`

Extend a class. You get most of the features you would expect: inherit or override methods from the super class. We currently use [John Resig's](http://ejohn.org/blog/simple-javascript-inheritance/) implementation for classical inheritence.

    var Person = Game3.Class.extend({
      init: function(name) { this.name = name; },
      talk: function() { return 'My name is ' + this.name + '!'; }
    });

    var Ninja = Person.extend({
      talk: function() { return 'Drinks at the ' + this.name + '.'; }
    });

    var person = new Person('Foo');
    var ninja = new Ninja('Bar');

    person.talk()                 // My name is Foo!
    ninja.talk()                  // Drinks at the Bar.
    ninja instanceof Person       // true
    ninja instanceof Game3.Class  // true


### Instance Methods

### `.after_init([args ...])`

This method is called right _after_ the `init()` method during construction. The intention here is to make it easy to wrap the logic of an overriden `init()` method (by a subclass, for example). This is to avoid calling the `_super()` method any time you need to do post set up work after some configuration.

__Note:__ `after_init()` is supplied the same arguments as the `init()` constructor.

    var File = Game3.Class.extend({
      init: function(name) { this.name = name; },
      after_init: function(name) { this.full = this.name + '.txt'; }
    });

    var file = new File('foo');
    file.name  // foo
    file.full  // foo.txt


### `.before_init([args ...])`

This method is called right _before_ the `init()` method during construction. The intention here is to make it easy to wrap the logic of an overriden `init()` method (by a subclass, for example). This is to avoid calling the `_super()` method any time you need to do post set up work after some configuration.

__Note:__ `before_init()` is supplied the same arguments as the `init()` constructor.

    var File = Game3.Class.extend({
      before_init: function(name) { this.ext = '.txt'; }
      init: function(name) { this.full = name + this.ext; },
    });

    var file = new File('foo');
    file.ext   // .txt
    file.full  // foo.txt


### `.init([args ...])`

This is the main constructor. Logic placed here will be executed when the object is instantiated. When you define an`init()` constructor for your class, you will override the superclass's `init()` method. You may still call the original method using `this._super(args ...)`.

    var File = Game3.Class.extend({
      init: function(name) { this.name = name + '.txt'; }
    });

    var file = new File('foo');
    file.name                    // foo.txt
    file instanceof Game3.Class  // true


## Game3.Collision

A `Collision` object is sent to any model that has experienced a collision. You can read more about collisions under the `Collisions` class and how to handle collisions in the `Model` class.

### Members

### `.point {THREE.Vector3}`
The closest point of intersection on the _other_ object.

### `.face {THREE.Face?}`
A reference to the face of the mesh on the _other_ object where intersetion occurred. This can be useful for deriving normals and other data.

__Note:__ If the `face` attribute is `null`, it means the collision was computed without ray-tracing. This can occur if you use special case collision detectors. See the `Collisions` class for more details.

### `.other {Game3.Model}`
The other model that was collided with. Useful for performing an action on that model. For example, in physics we may want to exchange momentum in an elastic collision.


### Instance Methods

### `.normal() {THREE.Vector3}`
The normal of the collision. In other words, the orientation of the surface the model collided with. This can be derived for special cases.

### `.correction() {THREE.Vector3}`
The `correction()` vector offers you (free of charge) a way to handle collisions robustly. Because `timerfired()` is called at about 60 FPS, it is possible for objects in the scene to overlap _before_ triggering a collision. Adding the `correction()` back to your object's position can __prevent some nasty bugs__.


## Game3.Collisions
The `Collisions` class gives you a great way to handle collisions in your `scene`. You _could_ handle all this yourself, which comes in handy if you need heavy customization.

### Constructor

### `Collisions([models [, type]])`
__`models`:__ An optional argument. This is an `Array` of `Game3.Model` objects to register with the `Collisions` object. You can always add or remove from this set later on during execution (using `track()` for example).

__`type`:__ If `type` is not specified, then `Game3.COLLISIONS_GENERAL` is used. This specifies the type of collision checking function to use. General works for most geometries, but it is slower.

Currently the only supported types are `Game3.COLLISIONS_GENERAL` and `Game3.COLLISIONS_SPHERES`. _Later we want to support custom check functions, if provided._

    init: function(el) {
      // setup stuff ...
      this.collisions = new Game3.Collisions(
          [this.redBall, this.blueBall], Game3.COLLISIONS_SPHERES);
    }


### Instance Methods

### `.check()`
This method iterates through every registered `Game3.Model` in the collection and determines whether or not a collision has occurred. If so, a `Collision` event object is created and sent to each model's respective collision handler. The `check()` method is usually called in `timerfired()`.

    timerfired: function() {
      this.collisions.check();
    }

### `.track(model)`
__`model`:__ The model to add to the collection.

All models in the collection will be checked for collisions, and sent `Collision` events accordingly.

    init: function(el) {
      // setup stuff ...
      this.collisions = new Game3.Collisions();
      this.collisions.track(this.redBall);
      this.collisions.track(this.blueBall);
    }

## Game3.Event
Coming soon.


## Game3.Game
Coming soon.

## Game3.Model
Coming soon.
    </article>
    <script type="text/javascript">
      var articles = document.getElementsByTagName('article');
      for (var i = 0; i < articles.length; i++) {
        var article = articles[i];
        article.innerHTML = markdown.toHTML(article.innerHTML);
      }
    </script>
  </div>
</body>
</html>