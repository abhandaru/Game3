<html>
<head>
  <title>Game3 | Docs</title>
  <!-- markdown stuff -->
  <script type="text/javascript" src="../js/markdown.min.js"></script>
  <!-- prettify stuff -->
  <link rel="stylesheet" href="../css/highlight.min.css">
  <script src="../js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- custom -->
  <link rel="stylesheet" type="text/css" href="../css/layout.css" />
</head>
<body>
  <div class="info">
    <div class="nav">
      <a href="../">Game3</a>
      <a href="../examples/">Examples</a>
      <a href="../docs/">Docs</a>
    </div>
    <h1>Documentation</h1>
    <p class="important">Under development.</p>
    <p>For now, be sure to check out the full example pages and the source code on <a href="https://github.com/abhandaru/Game3">GitHub</a>. The code itself is well formed, commented, and split into files.</p>
    <article>
## Game3.Class

All classes in `Game3` derive from the base `Class`. It supports a familiar inheritance model, and should prove useful in your object oriented designs.


### Static Methods

### `.extend([parameters])`

Extend a class. You get most of the features you would expect: inherit or override methods from the super class. We currently use [John Resig's](http://ejohn.org/blog/simple-javascript-inheritance/) implementation for classical inheritence.

    var Person = Game3.Class.extend({
      init: function(name) { this.name = name; },
      talk: function() { return 'My name is ' + this.name + '!'; }
    });

    var Ninja = Person.extend({
      talk: function() { return 'Drinks at the ' + this.name + '.'; }
    });

    var person = new Person('Foo');
    var ninja = new Ninja('Bar');

    person.talk()           // My name is Foo!
    ninja.talk()            // Drinks at the Bar.
    ninja instanceof Person // true
    ninja instanceof Class  // true


### Instance Methods

### `.after_init(args ...)`

This method is called right _after_ the `init()` method during construction. The intention here is to make it easy to wrap the logic of an overriden `init()` method (by a subclass, for example). This is to avoid calling the `_super()` method any time you need to do post set up work after some configuration.

__Note:__ `after_init()` is supplied the same arguments as the `init()` constructor.

    var File = Game3.Class.extend({
      init: function(name) { this.name = name; },
      after_init: function(name) { this.full = this.name + '.txt'; }
    });

    var file = new File('foo');
    file.name  // foo
    file.full  // foo.txt


### `.before_init(args ...)`

This method is called right _before_ the `init()` method during construction. The intention here is to make it easy to wrap the logic of an overriden `init()` method (by a subclass, for example). This is to avoid calling the `_super()` method any time you need to do post set up work after some configuration.

__Note:__ `before_init()` is supplied the same arguments as the `init()` constructor.

    var File = Game3.Class.extend({
      before_init: function(name) { this.ext = '.txt'; }
      init: function(name) { this.full = name + this.ext; },
    });

    var file = new File('foo');
    file.ext   // .txt
    file.full  // foo.txt


### `.init(args ...)`

This is the main constructor. Logic placed here will be executed when the object is instantiated. When you define an`init()` constructor for your class, you will override the superclass's `init()` method. You may still call the original method using `this._super(args ...)`.


## Game3.Collision

A `Collision` object is sent to any model that has experienced a collision. You can read more about collisions under the `Collisions` class and how to handle collisions in the `Model` class.

### Members

### `.point {THREE.Vector3}`
The closest point of intersection on the _other_ object.

### `.face {THREE.Face?}`
A reference to the face of the mesh on the _other_ object where intersetion occurred. This can be useful for deriving normals and other data.

__Note:__ If the `face` attribute is `null`, it means the collision was computed without ray-tracing. This can occur if you use special case collision detectors. See the `Collisions` class for more details.

### `.other {Game3.Model}`
The other model that was collided with. Useful for performing an action on that model. For example, in physics we may want to exchange momentum in an elastic collision.


### Instance Methods

### `.normal() {THREE.Vector3}`
The normal of the collision. In other words, the orientation of the surface the model collided with. This can be derived for special cases.

### `.correction() {THREE.Vector3}`
The `correction()` vector offers you (free of charge) a way to handle collisions robustly. Because `timerfired()` is called at about 60 FPS, it is possible for objects in the scene to overlap _before_ triggering a collision. Adding the `correction()` back to your object's position can __prevent some nasty bugs__.


## Game3.Collisions

Coming soon.


## Game3.Event

Coming soon.


## Game3.Game


## Game3.Model
    </article>
    <script type="text/javascript">
      var articles = document.getElementsByTagName('article');
      for (var i = 0; i < articles.length; i++) {
        var article = articles[i];
        article.innerHTML = markdown.toHTML(article.innerHTML);
      }
    </script>
  </div>
</body>
</html>